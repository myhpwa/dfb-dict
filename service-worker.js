try{self["workbox:core:5.1.4"]&&_()}catch{}const k=(t,...e)=>{let n=t;return e.length>0&&(n+=` :: ${JSON.stringify(e)}`),n},H=k;class d extends Error{constructor(e,n){const s=H(e,n);super(s),this.name=e,this.details=n}}const $=new Set,p={googleAnalytics:"googleAnalytics",precache:"precache-v2",prefix:"workbox",runtime:"runtime",suffix:typeof registration<"u"?registration.scope:""},K=t=>[p.prefix,t,p.suffix].filter(e=>e&&e.length>0).join("-"),V=t=>{for(const e of Object.keys(p))t(e)},v={updateDetails:t=>{V(e=>{typeof t[e]=="string"&&(p[e]=t[e])})},getGoogleAnalyticsName:t=>t||K(p.googleAnalytics),getPrecacheName:t=>t||K(p.precache),getPrefix:()=>p.prefix,getRuntimeName:t=>t||K(p.runtime),getSuffix:()=>p.suffix};async function G(){for(const t of $)await t()}const Q=t=>new URL(String(t),location.href).href.replace(new RegExp(`^${location.origin}`),""),E={filter:(t,e)=>t.filter(n=>e in n)},D=async({request:t,mode:e,plugins:n=[]})=>{const s=E.filter(n,"cacheKeyWillBeUsed");let r=t;for(const o of s)r=await o.cacheKeyWillBeUsed.call(o,{mode:e,request:r}),typeof r=="string"&&(r=new Request(r));return r},z=async({request:t,response:e,event:n,plugins:s=[]})=>{let r=e,o=!1;for(const a of s)if("cacheWillUpdate"in a&&(o=!0,r=await a.cacheWillUpdate.call(a,{request:t,response:r,event:n}),!r))break;return o||(r=r&&r.status===200?r:void 0),r||null},F=async({cacheName:t,request:e,event:n,matchOptions:s,plugins:r=[]})=>{const o=await self.caches.open(t),a=await D({plugins:r,request:e,mode:"read"});let c=await o.match(a,s);for(const i of r)"cachedResponseWillBeUsed"in i&&(c=await i.cachedResponseWillBeUsed.call(i,{cacheName:t,event:n,matchOptions:s,cachedResponse:c,request:a}));return c},J=async({cacheName:t,request:e,response:n,event:s,plugins:r=[],matchOptions:o})=>{const a=await D({plugins:r,request:e,mode:"write"});if(!n)throw new d("cache-put-with-no-response",{url:Q(a.url)});const c=await z({event:s,plugins:r,response:n,request:a});if(!c)return;const i=await self.caches.open(t),h=E.filter(r,"cacheDidUpdate"),u=h.length>0?await F({cacheName:t,matchOptions:o,request:a}):null;try{await i.put(a,c)}catch(l){throw l.name==="QuotaExceededError"&&await G(),l}for(const l of h)await l.cacheDidUpdate.call(l,{cacheName:t,event:s,oldResponse:u,newResponse:c,request:a})},X={put:J,match:F};let y;function Y(){if(y===void 0){const t=new Response("");if("body"in t)try{new Response(t.body),y=!0}catch{y=!1}y=!1}return y}class B{constructor(e,n,{onupgradeneeded:s,onversionchange:r}={}){this._db=null,this._name=e,this._version=n,this._onupgradeneeded=s,this._onversionchange=r||(()=>this.close())}get db(){return this._db}async open(){if(!this._db)return this._db=await new Promise((e,n)=>{let s=!1;setTimeout(()=>{s=!0,n(new Error("The open request was blocked and timed out"))},this.OPEN_TIMEOUT);const r=indexedDB.open(this._name,this._version);r.onerror=()=>n(r.error),r.onupgradeneeded=o=>{s?(r.transaction.abort(),r.result.close()):typeof this._onupgradeneeded=="function"&&this._onupgradeneeded(o)},r.onsuccess=()=>{const o=r.result;s?o.close():(o.onversionchange=this._onversionchange.bind(this),e(o))}}),this}async getKey(e,n){return(await this.getAllKeys(e,n,1))[0]}async getAll(e,n,s){return await this.getAllMatching(e,{query:n,count:s})}async getAllKeys(e,n,s){return(await this.getAllMatching(e,{query:n,count:s,includeKeys:!0})).map(o=>o.key)}async getAllMatching(e,{index:n,query:s=null,direction:r="next",count:o,includeKeys:a=!1}={}){return await this.transaction([e],"readonly",(c,i)=>{const h=c.objectStore(e),u=n?h.index(n):h,l=[],C=u.openCursor(s,r);C.onsuccess=()=>{const g=C.result;g?(l.push(a?g:g.value),o&&l.length>=o?i(l):g.continue()):i(l)}})}async transaction(e,n,s){return await this.open(),await new Promise((r,o)=>{const a=this._db.transaction(e,n);a.onabort=()=>o(a.error),a.oncomplete=()=>r(),s(a,c=>r(c))})}async _call(e,n,s,...r){const o=(a,c)=>{const i=a.objectStore(n),h=i[e].apply(i,r);h.onsuccess=()=>c(h.result)};return await this.transaction([n],s,o)}close(){this._db&&(this._db.close(),this._db=null)}}B.prototype.OPEN_TIMEOUT=2e3;const Z={readonly:["get","count","getKey","getAll","getAllKeys"],readwrite:["add","put","clear","delete"]};for(const[t,e]of Object.entries(Z))for(const n of e)n in IDBObjectStore.prototype&&(B.prototype[n]=async function(s,...r){return await this._call(n,s,t,...r)});const ee=async({request:t,fetchOptions:e,event:n,plugins:s=[]})=>{if(typeof t=="string"&&(t=new Request(t)),n instanceof FetchEvent&&n.preloadResponse){const c=await n.preloadResponse;if(c)return c}const r=E.filter(s,"fetchDidFail"),o=r.length>0?t.clone():null;try{for(const c of s)if("requestWillFetch"in c){const i=c.requestWillFetch,h=t.clone();t=await i.call(c,{request:h,event:n})}}catch(c){throw new d("plugin-error-request-will-fetch",{thrownError:c})}const a=t.clone();try{let c;t.mode==="navigate"?c=await fetch(t):c=await fetch(t,e);for(const i of s)"fetchDidSucceed"in i&&(c=await i.fetchDidSucceed.call(i,{event:n,request:a,response:c}));return c}catch(c){for(const i of r)await i.fetchDidFail.call(i,{error:c,event:n,originalRequest:o.clone(),request:a.clone()});throw c}},te={fetch:ee};async function ne(t,e){const n=t.clone(),r={headers:new Headers(n.headers),status:n.status,statusText:n.statusText},o=Y()?n.body:await n.blob();return new Response(o,r)}function se(){self.addEventListener("activate",()=>self.clients.claim())}try{self["workbox:precaching:5.1.4"]&&_()}catch{}const q=[],re={get(){return q},add(t){q.push(...t)}},oe="__WB_REVISION__";function ce(t){if(!t)throw new d("add-to-cache-list-unexpected-type",{entry:t});if(typeof t=="string"){const o=new URL(t,location.href);return{cacheKey:o.href,url:o.href}}const{revision:e,url:n}=t;if(!n)throw new d("add-to-cache-list-unexpected-type",{entry:t});if(!e){const o=new URL(n,location.href);return{cacheKey:o.href,url:o.href}}const s=new URL(n,location.href),r=new URL(n,location.href);return s.searchParams.set(oe,e),{cacheKey:s.href,url:r.href}}class ae{constructor(e){this._cacheName=v.getPrecacheName(e),this._urlsToCacheKeys=new Map,this._urlsToCacheModes=new Map,this._cacheKeysToIntegrities=new Map}addToCacheList(e){const n=[];for(const s of e){typeof s=="string"?n.push(s):s&&s.revision===void 0&&n.push(s.url);const{cacheKey:r,url:o}=ce(s),a=typeof s!="string"&&s.revision?"reload":"default";if(this._urlsToCacheKeys.has(o)&&this._urlsToCacheKeys.get(o)!==r)throw new d("add-to-cache-list-conflicting-entries",{firstEntry:this._urlsToCacheKeys.get(o),secondEntry:r});if(typeof s!="string"&&s.integrity){if(this._cacheKeysToIntegrities.has(r)&&this._cacheKeysToIntegrities.get(r)!==s.integrity)throw new d("add-to-cache-list-conflicting-integrities",{url:o});this._cacheKeysToIntegrities.set(r,s.integrity)}if(this._urlsToCacheKeys.set(o,r),this._urlsToCacheModes.set(o,a),n.length>0){const c=`Workbox is precaching URLs without revision info: ${n.join(", ")}
This is generally NOT safe. Learn more at https://bit.ly/wb-precache`;console.warn(c)}}}async install({event:e,plugins:n}={}){const s=[],r=[],a=await(await self.caches.open(this._cacheName)).keys(),c=new Set(a.map(u=>u.url));for(const[u,l]of this._urlsToCacheKeys)c.has(l)?r.push(u):s.push({cacheKey:l,url:u});const i=s.map(({cacheKey:u,url:l})=>{const C=this._cacheKeysToIntegrities.get(u),g=this._urlsToCacheModes.get(l);return this._addURLToCache({cacheKey:u,cacheMode:g,event:e,integrity:C,plugins:n,url:l})});return await Promise.all(i),{updatedURLs:s.map(u=>u.url),notUpdatedURLs:r}}async activate(){const e=await self.caches.open(this._cacheName),n=await e.keys(),s=new Set(this._urlsToCacheKeys.values()),r=[];for(const o of n)s.has(o.url)||(await e.delete(o),r.push(o.url));return{deletedURLs:r}}async _addURLToCache({cacheKey:e,url:n,cacheMode:s,event:r,plugins:o,integrity:a}){const c=new Request(n,{integrity:a,cache:s,credentials:"same-origin"});let i=await te.fetch({event:r,plugins:o,request:c}),h;for(const l of o||[])"cacheWillUpdate"in l&&(h=l);if(!(h?await h.cacheWillUpdate({event:r,request:c,response:i}):i.status<400))throw new d("bad-precaching-response",{url:n,status:i.status});i.redirected&&(i=await ne(i)),await X.put({event:r,plugins:o,response:i,request:e===n?c:new Request(e),cacheName:this._cacheName,matchOptions:{ignoreSearch:!0}})}getURLsToCacheKeys(){return this._urlsToCacheKeys}getCachedURLs(){return[...this._urlsToCacheKeys.keys()]}getCacheKeyForURL(e){const n=new URL(e,location.href);return this._urlsToCacheKeys.get(n.href)}async matchPrecache(e){const n=e instanceof Request?e.url:e,s=this.getCacheKeyForURL(n);if(s)return(await self.caches.open(this._cacheName)).match(s)}createHandler(e=!0){return async({request:n})=>{try{const s=await this.matchPrecache(n);if(s)return s;throw new d("missing-precache-entry",{cacheName:this._cacheName,url:n instanceof Request?n.url:n})}catch(s){if(e)return fetch(n);throw s}}}createHandlerBoundToURL(e,n=!0){if(!this.getCacheKeyForURL(e))throw new d("non-precached-url",{url:e});const r=this.createHandler(n),o=new Request(e);return()=>r({request:o})}}let P;const b=()=>(P||(P=new ae),P);function ie(t,e=[]){for(const n of[...t.searchParams.keys()])e.some(s=>s.test(n))&&t.searchParams.delete(n);return t}function*le(t,{ignoreURLParametersMatching:e,directoryIndex:n,cleanURLs:s,urlManipulation:r}={}){const o=new URL(t,location.href);o.hash="",yield o.href;const a=ie(o,e);if(yield a.href,n&&a.pathname.endsWith("/")){const c=new URL(a.href);c.pathname+=n,yield c.href}if(s){const c=new URL(a.href);c.pathname+=".html",yield c.href}if(r){const c=r({url:o});for(const i of c)yield i.href}}const he=(t,e)=>{const s=b().getURLsToCacheKeys();for(const r of le(t,e)){const o=s.get(r);if(o)return o}},ue=({ignoreURLParametersMatching:t=[/^utm_/],directoryIndex:e="index.html",cleanURLs:n=!0,urlManipulation:s}={})=>{const r=v.getPrecacheName();self.addEventListener("fetch",o=>{const a=he(o.request.url,{cleanURLs:n,directoryIndex:e,ignoreURLParametersMatching:t,urlManipulation:s});if(!a)return;let c=self.caches.open(r).then(i=>i.match(a)).then(i=>i||fetch(a));o.respondWith(c)})};let I=!1;function de(t){I||(ue(t),I=!0)}function fe(t){return b().createHandlerBoundToURL(t)}const pe=t=>{const e=b(),n=re.get();t.waitUntil(e.install({event:t,plugins:n}).catch(s=>{throw s}))},ge=t=>{const e=b();t.waitUntil(e.activate())};function we(t){b().addToCacheList(t),t.length>0&&(self.addEventListener("install",pe),self.addEventListener("activate",ge))}function ye(t,e){we(t),de(e)}try{self["workbox:routing:5.1.4"]&&_()}catch{}const me="GET",S=t=>t&&typeof t=="object"?t:{handle:t};class L{constructor(e,n,s=me){this.handler=S(n),this.match=e,this.method=s}}class Re extends L{constructor(e,n,s){const r=({url:o})=>{const a=e.exec(o.href);if(a&&!(o.origin!==location.origin&&a.index!==0))return a.slice(1)};super(r,n,s)}}class _e{constructor(){this._routes=new Map}get routes(){return this._routes}addFetchListener(){self.addEventListener("fetch",e=>{const{request:n}=e,s=this.handleRequest({request:n,event:e});s&&e.respondWith(s)})}addCacheListener(){self.addEventListener("message",e=>{if(e.data&&e.data.type==="CACHE_URLS"){const{payload:n}=e.data,s=Promise.all(n.urlsToCache.map(r=>{typeof r=="string"&&(r=[r]);const o=new Request(...r);return this.handleRequest({request:o})}));e.waitUntil(s),e.ports&&e.ports[0]&&s.then(()=>e.ports[0].postMessage(!0))}})}handleRequest({request:e,event:n}){const s=new URL(e.url,location.href);if(!s.protocol.startsWith("http"))return;const{params:r,route:o}=this.findMatchingRoute({url:s,request:e,event:n});let a=o&&o.handler;if(!a&&this._defaultHandler&&(a=this._defaultHandler),!a)return;let c;try{c=a.handle({url:s,request:e,event:n,params:r})}catch(i){c=Promise.reject(i)}return c instanceof Promise&&this._catchHandler&&(c=c.catch(i=>this._catchHandler.handle({url:s,request:e,event:n}))),c}findMatchingRoute({url:e,request:n,event:s}){const r=this._routes.get(n.method)||[];for(const o of r){let a;const c=o.match({url:e,request:n,event:s});if(c)return a=c,(Array.isArray(c)&&c.length===0||c.constructor===Object&&Object.keys(c).length===0||typeof c=="boolean")&&(a=void 0),{route:o,params:a}}return{}}setDefaultHandler(e){this._defaultHandler=S(e)}setCatchHandler(e){this._catchHandler=S(e)}registerRoute(e){this._routes.has(e.method)||this._routes.set(e.method,[]),this._routes.get(e.method).push(e)}unregisterRoute(e){if(!this._routes.has(e.method))throw new d("unregister-route-but-not-found-with-method",{method:e.method});const n=this._routes.get(e.method).indexOf(e);if(n>-1)this._routes.get(e.method).splice(n,1);else throw new d("unregister-route-route-not-registered")}}let m;const be=()=>(m||(m=new _e,m.addFetchListener(),m.addCacheListener()),m);function A(t,e,n){let s;if(typeof t=="string"){const o=new URL(t,location.href),a=({url:c})=>c.href===o.href;s=new L(a,e,n)}else if(t instanceof RegExp)s=new Re(t,e,n);else if(typeof t=="function")s=new L(t,e,n);else if(t instanceof L)s=t;else throw new d("unsupported-route-type",{moduleName:"workbox-routing",funcName:"registerRoute",paramName:"capture"});return be().registerRoute(s),s}const Ce={indexedDBHost:"indexdb.com"},M="dfb-dict-db",W=1,w="store",Ue=5,j="font",x=[w,j];let U,f,R=!1;async function T(){if(!R)return new Promise(t=>{const e=setInterval(()=>{R&&(clearInterval(e),t())},20)})}async function Le(){if(!R)return new Promise((t,e)=>{U=indexedDB.open(M,W),U.onupgradeneeded=async n=>{f=n.target.result;let s;for(let r=0;r<x.length;r++){const o=x[r];f.objectStoreNames.contains(o)||(s=f.createObjectStore(o))}await new Promise((r,o)=>{if(!s){r();return}s.transaction.oncomplete=()=>{r()},s.transaction.onerror=a=>{o(`createObjectStore error: ${a.target.error}`)}}),R=!0,console.log(`IndexedDB upgraded to version: ${W}`)},U.onsuccess=n=>{f=n.target.result,f.version===W&&(R=!0),t(),console.log("IndexedDB opened successfully.")},U.onerror=n=>{e("Fail to create IndexedDB.")}})}async function xe(){for(let t=0;t<x.length;t++)await N(x[t])}async function N(t){return new Promise((e,n)=>{const r=f.transaction([t],"readwrite").objectStore(t).clear();r.onsuccess=o=>e(),r.onerror=o=>n(`Clear IndexedDB failed: ${o.target.error}`)})}async function Te(t,e,n=w){return await T(),new Promise((s,r)=>{try{const a=f.transaction([n],"readwrite").objectStore(n).put(e,t);a.onsuccess=c=>s(),a.onerror=c=>r(`File ${t} saving failed: ${c.target.error}`)}catch(o){r(o)}})}async function Ke(t,e=w){return await T(),new Promise((n,s)=>{try{const o=f.transaction([e],"readwrite").objectStore(e).delete(t);o.onsuccess=a=>n(),o.onerror=a=>s(`File ${t} removing failed: ${a.target.error}`)}catch(r){s(r)}})}async function Pe(t,e=w){return await T(),new Promise(function(n,s){try{let o=f.transaction([e],"readonly").objectStore(e).getKey(t);o.onsuccess=async function(a){const c=o.result;return c?n(c):s(`Key ${t} not found in IndexedDB`)}}catch(r){s(r)}})}async function We(t,e=w){return await T(),new Promise(function(n,s){try{let o=f.transaction([e],"readwrite").objectStore(e).get(t);o.onsuccess=async function(a){const c=o.result;return c?n(c):s(`File ${t} not found in IndexedDB.`)}}catch(r){s(r)}})}const O={dfbdictDb:M,dataStore:w,twKaiFontVersion:Ue,fontStore:j,open:Le,clear:xe,clearStore:N,saveFile:Te,removeFile:Ke,getFile:We,checkKey:Pe};O.open().then(()=>{console.log("SW IndexedDB opened!")}).catch(t=>{console.log("SW IndexedDB failed!")});se();ye([{"revision":"2386e16a864fb2a31cd1610ae32b7529","url":"index.html"},{"revision":"e43aad698669fa1048324340762fa5ed","url":"404.html"},{"revision":null,"url":"assets/swipe-back-BZ8CKDXJ.js"},{"revision":null,"url":"assets/status-tap-BxDOH5XC.js"},{"revision":null,"url":"assets/md.transition-DSja_UoH.js"},{"revision":null,"url":"assets/ios.transition-B48HDwbt.js"},{"revision":null,"url":"assets/input-shims-Ze_miFZK.js"},{"revision":null,"url":"assets/index9-BNb_Tb7a.js"},{"revision":null,"url":"assets/index-DUx0xUzI.css"},{"revision":null,"url":"assets/index-BOKWBxg1.js"},{"revision":null,"url":"assets/focus-visible-supuXXMI.js"},{"revision":"4feb375d371da34118a74954d4b61a3d","url":"assets/icon/icon.png"},{"revision":"bea5de07d225afcb1885566c61ad45fd","url":"manifest.json"}]);const Se=new RegExp("/[^/?]+\\.[^/]+$");A(({request:t,url:e})=>!(t.mode!=="navigate"||e.pathname.startsWith("/_")||e.pathname.match(Se)),fe("/dfb-dict/index.html"));self.addEventListener("message",t=>{t.data&&t.data.type==="SKIP_WAITING"&&self.skipWaiting()});A(t=>t.url.host===Ce.indexedDBHost,async({url:t})=>{const e=await O.getFile((t==null?void 0:t.pathname)||"");return new Response(e)});
